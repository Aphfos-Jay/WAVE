package com.example.remote

import android.Manifest
import android.app.*
import android.content.*
import android.content.pm.PackageManager
import android.os.*
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import ai.picovoice.porcupine.PorcupineManager
import kotlinx.coroutines.*
import java.io.File
import java.io.FileOutputStream
import java.util.*
import java.util.regex.Pattern
import org.json.JSONObject

// Î∞±Í∑∏ÎùºÏö¥Îìú ÏùåÏÑ± Í¥ÄÎ†® ÏÑúÎπÑÏä§
// Picovoice PorcupineÏúºÎ°ú Ìò∏Ï∂úÏñ¥ Í∞êÏßÄ
// Controller Î™®Îìú: STT ‚Üí ÏÑúÎ≤Ñ Ï†ÑÏÜ°
// RC Î™®Îìú: ÏÑúÎ≤ÑÏóêÏÑú Ïò® TTS Ï∂úÎ†• Ï†ÑÎã¥
// ÏùåÏÑ± Í∏∞Î∞ò Ï†úÏñ¥ Î™ÖÎ†π/ÎåÄÌôî Ï≤òÎ¶¨ + WebSocket ÌÜµÏã† + TTS Ïã§Ìñâ

class PorcupineService : Service() {

    private var porcupineManager: PorcupineManager? = null
    private var tts: TextToSpeech? = null
    private var speechRecognizer: SpeechRecognizer? = null
    private lateinit var recognizerIntent: Intent
    private lateinit var wsManager: WebSocketManager

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private var voiceMacroJob: Job? = null // ÏùåÏÑ± Îß§ÌÅ¨Î°ú Ïã§ÌñâÏùÑ Ï†úÏñ¥ÌïòÍ∏∞ ÏúÑÌïú Job

    private val KOR_COMMAND = mapOf(
        "Forward" to "ÏïûÏúºÎ°ú",
        "Back" to "Îí§Î°ú",
        "Forward-Left" to "Ï¢åÌöåÏ†Ñ",
        "Forward-Right" to "Ïö∞ÌöåÏ†Ñ"
    )

    companion object {
        const val ACTION_START_FOREGROUND_SERVICE = "com.example.remote.START_SERVICE"
        const val ACTION_STOP_FOREGROUND_SERVICE = "com.example.remote.STOP_SERVICE"
        const val ACTION_START_STT = "com.example.remote.START_STT"
        const val ACTION_STOP_STT = "com.example.remote.STOP_STT"
        const val ACTION_SPEAK_OUT = "com.example.remote.SPEAK"
        const val EXTRA_TEXT_TO_SPEAK = "text"
        const val ACTION_UPDATE_STATUS = "com.example.remote.STATUS"
        const val EXTRA_STATUS_MESSAGE = "status"
        const val ACTION_UPDATE_RMS = "com.example.remote.RMS"
        const val EXTRA_RMS_VALUE = "rms"
        const val ACTION_LOG_CONVERSATION = "com.example.remote.LOG"
        const val EXTRA_LOG_TYPE = "log_type"
        const val EXTRA_LOG_CONTENT = "log_content"
        const val ACTION_SEND_CONTROL_COMMAND = "com.example.remote.SEND_CONTROL"
        const val EXTRA_CONTROL_COMMAND_JSON = "control_json"

        // Ï†úÏñ¥ ÎùΩ(Lock) ÏÉÅÌÉúÎ•º Ï†ÑÎã¨ÌïòÍ∏∞ ÏúÑÌïú Action Ï∂îÍ∞Ä
        const val ACTION_SET_CONTROL_LOCK = "com.example.remote.SET_LOCK"
        const val EXTRA_IS_LOCKED = "is_locked"
    }


    private fun getAppMode(): String {
        val prefs = getSharedPreferences(MainActivity.PREFS, MODE_PRIVATE)
        return prefs.getString(MainActivity.KEY_MODE, "controller") ?: "controller"
    }
    private fun isRc(): Boolean = getAppMode() == "rc"
    private fun isController(): Boolean = !isRc()
    private fun shouldSpeak(): Boolean = isRc()

    private val serviceWsListener: (type: String, content: String) -> Unit = { type, content ->
        when (type) {
            "Tts", "response" -> {
                if (isController()) {
                    sendTtsCommandOverTcp(content)
                } else if (isRc()) {
                    speakOut(content)
                }
            }

            // CapAnalysis Ï≤òÎ¶¨ Ï∂îÍ∞Ä
            "CapAnalysis" -> {
                try {
                    val json = JSONObject(content)
                    val id = json.optString("ID", "")
                    val resultText = json.optString("result", "")
                    val summary = extractSummary(resultText)
                    val finalSummary = if (summary == "Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ Î∂àÍ∞Ä")
                        "Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî."
                    else summary

                    // Î°úÏª¨ SharedPreferencesÏóê Ï†ÄÏû•
                    saveAnalysisToPrefs(id, resultText)

                    // 1) RCÎ°ú ÏöîÏïΩÎ≥∏ TTS Ï†ÑÏÜ°
                    val ttsJson = JsonFactory.createTtsRequestMessage(finalSummary)
                    RpiWebSocketManager.sendText(ttsJson)

                    // 2) Ï†ÑÏ≤¥ ÏõêÎ¨∏ÏùÄ Î°úÍ∑∏/Ï†ÄÏû•Ïö©ÏúºÎ°ú ÎÇ®Í∏∞Í∏∞
                    sendStatus("üß† AI Î∂ÑÏÑù Í≤∞Í≥º ÏàòÏã†")
                    sendStatus("üß† CapAnalysis ÏöîÏïΩ: $finalSummary")
                    logConversation("CapAnalysis", resultText)
                    logConversation("CapAnalysis_Summary", finalSummary)

                } catch (e: Exception) {
                    sendStatus("‚ùå CapAnalysis Ï≤òÎ¶¨ Ïã§Ìå®: ${e.message}")
                }
            }


            // AgentÏùëÎãµ Ï≤òÎ¶¨ Ï∂îÍ∞Ä
            "SttResult" -> {
                try {
                    val json = JSONObject(content)
                    val reply = json.optString("Text", content)

                    // RCÍ∞Ä ÏùΩÏùÑ Ïàò ÏûàÎèÑÎ°ù Tts ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                    val msg = JsonFactory.createTtsRequestMessage(reply)

                    RpiWebSocketManager.sendText(msg)

                    sendStatus("ü§ñ GPT ÏùëÎãµ Ï†ÑÎã¨(Tts): $reply")
                    logConversation("SttResult", reply)
                } catch (e: Exception) {
                    sendStatus("‚ùå SttResult Ï≤òÎ¶¨ Ïã§Ìå®: ${e.message}")
                }
            }


        }
    }

    private fun saveAnalysisToPrefs(id: String, analysis: String) {
        val prefs = getSharedPreferences("analysis_store", MODE_PRIVATE)
        prefs.edit().putString(id, analysis).apply()
    }


    override fun onCreate() {
        super.onCreate()
        initNotification()
        initTextToSpeech()

        wsManager = WebSocketManager.getInstance()
        wsManager.addEventListener(serviceWsListener) // ÏÑúÎπÑÏä§Ïùò Î¶¨Ïä§ÎÑà Îì±Î°ù

        if (isController()) {
            initSpeechRecognizer()
            initPorcupine()
            sendStatus("üéÆ Ï°∞Ï¢ÖÍ∏∞ Î™®Îìú: Ìò∏Ï∂úÏñ¥/ÏùåÏÑ± Ïù∏Ïãù ÌôúÏÑ±")
        } else {
            sendStatus("ü§ñ RC Î™®Îìú: TTS Ï†ÑÎã¥, Ìò∏Ï∂úÏñ¥/ÏùåÏÑ± Ïù∏Ïãù ÎπÑÌôúÏÑ±")
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_FOREGROUND_SERVICE -> startForegroundNotification("Ìò∏Ï∂úÏñ¥ Ïù∏Ïãù Ï§ÄÎπÑ Ï§ë...")
            ACTION_STOP_FOREGROUND_SERVICE -> {
                stopSTT()
                stopForeground(Service.STOP_FOREGROUND_REMOVE)
                stopSelf()
            }
            ACTION_START_STT -> {
                if (isController()) {
                    porcupineManager?.stop()
                    startSTT()
                } else {
                    sendStatus("RC Î™®ÎìúÏóêÏÑúÎäî STTÍ∞Ä ÎπÑÌôúÏÑ±ÏûÖÎãàÎã§.")
                }
            }
            ACTION_STOP_STT -> stopSTT()
            ACTION_SPEAK_OUT -> {
                val text = intent.getStringExtra(EXTRA_TEXT_TO_SPEAK)
                Log.d("PorcupineService", "TTS Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÏàòÏã†: $text")
                if (text != null && shouldSpeak()) speakOut(text)
            }
        }
        return START_STICKY
    }

    override fun onDestroy() {
        wsManager.removeEventListener(serviceWsListener) // Î¶¨Ïä§ÎÑà Ìï¥Ï†ú
        stopSTT()
        porcupineManager?.delete()
        porcupineManager = null
        tts?.shutdown()
        tts = null
        speechRecognizer?.destroy()
        speechRecognizer = null
        serviceScope.cancel()
        super.onDestroy()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun initNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("voice_channel", "Voice Service", NotificationManager.IMPORTANCE_LOW)
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }
    }

    private fun startForegroundNotification(msg: String) {
        val intent = Intent(this, MainActivity::class.java)
        val pending = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)
        val notification = NotificationCompat.Builder(this, "voice_channel")
            .setContentTitle("SurfBoard")
            .setContentText(msg)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentIntent(pending)
            .build()
        startForeground(1, notification)
    }



    // TTS Í∏∞Î≥∏ ÏÑ§Ï†ï - ÌòÑÏû¨Îäî ÎÇ®ÏÑ± Î™©ÏÜåÎ¶¨Î°ú Í∞ïÏ†ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§
    private fun initTextToSpeech() {
        tts = TextToSpeech(this) { status ->
            if (status == TextToSpeech.SUCCESS) {
                tts?.language = Locale.KOREAN

                // VoiceÎ•º Ïù¥Î¶ÑÏúºÎ°ú ÏßÅÏ†ë ÏßÄÏ†ï
                val maleVoice = tts?.voices?.find { it.name == "ko-kr-x-koc-local" }
                if (maleVoice != null) {
                    tts?.voice = maleVoice
                } else {
                }
            } else {
                log("TTS Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
            }
        }
    }

    private fun sendTtsCommandToFragment(text: String) {
        val ttsJson = JsonFactory.createTtsRequestMessage(text)
        val intent = Intent(PorcupineService.ACTION_SEND_CONTROL_COMMAND).apply {
            putExtra(PorcupineService.EXTRA_CONTROL_COMMAND_JSON, ttsJson)
        }
        sendBroadcast(intent)
    }

    private fun sendTtsCommandOverTcp(text: String) {
        val ttsJson = JsonFactory.createTtsRequestMessage(text)
        val intent = Intent(ACTION_SEND_CONTROL_COMMAND).apply {
            putExtra(EXTRA_CONTROL_COMMAND_JSON, ttsJson)
        }
        sendBroadcast(intent) // ‚Üê ControllerFragment Í∞Ä Î∞õÏïÑÏÑú TCP Ï†ÑÏÜ°
    }



    private fun speakOut(text: String, utteranceId: String? = "utterance_tts") {
        val params = Bundle().apply {
            putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
        }
        tts?.speak(text, TextToSpeech.QUEUE_FLUSH, params, utteranceId)
        logConversation("TTS", text)
        sendStatus("üîä $text")
    }

    private fun initPorcupine() {
        try {
            val keywordPath = getAssetFilePath("surf.ppn")
            val modelPath = getAssetFilePath("porcupine_params_ko.pv")

            porcupineManager = PorcupineManager.Builder()
                .setAccessKey(BuildConfig.PORCUPINE_KEY)
                .setKeywordPath(keywordPath)
                .setModelPath(modelPath)
                .setSensitivity(0.7f)
                .build(applicationContext) {
                    sendStatus("üü¢ Ìò∏Ï∂úÏñ¥ Ïù∏ÏãùÎê®")
                    logConversation("Hotword", "Ìò∏Ï∂úÏñ¥Í∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§")

                    // RCÏóêÏÑú Î∞îÎ°ú "ÎÑ§, ÎßêÏîÄÌïòÏÑ∏Ïöî" Î∞úÌôî
                    val ttsJson = JsonFactory.createTtsRequestMessage("ÎÑ§, ÎßêÏîÄÌïòÏÑ∏Ïöî")
                    RpiWebSocketManager.sendText(ttsJson)

                    porcupineManager?.stop()

                    if (isController()) {
                        Handler(Looper.getMainLooper()).postDelayed({
                            startSTT()
                        }, 1600)
                    }
                }

            porcupineManager?.start()
        } catch (e: Exception) {
            sendStatus("Hotword Ï¥àÍ∏∞Ìôî Ïã§Ìå®: ${e.message}")
        }
    }

    private fun initSpeechRecognizer() {
        speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this)
        recognizerIntent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, "ko-KR")
            putExtra(RecognizerIntent.EXTRA_PROMPT, "Î™ÖÎ†πÏñ¥Î•º ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî")
            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS, 3000L)
            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS, 3000L)
            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_MINIMUM_LENGTH_MILLIS, 1000L)
            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
        }
        speechRecognizer?.setRecognitionListener(object : RecognitionListener {
            override fun onReadyForSpeech(params: Bundle?) { sendStatus("üé§ ÏùåÏÑ± Ïù∏Ïãù Ï§ÄÎπÑÎê®") }

            override fun onResults(results: Bundle?) {
                val recognizedText = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)?.firstOrNull() ?: "Ïù∏Ïãù Ïã§Ìå®"
                logConversation("STT Í≤∞Í≥º", recognizedText)
                parseAndRouteStt(recognizedText) // << Î°úÏßÅÏùÄ Ïù¥ Ìï®ÏàòÎ°ú ÌÜµÌï©
                // ÌõÑÏ≤òÎ¶¨ ÏΩîÎìúÎäî parseAndRouteStt ÎÇ¥Î∂ÄÏóêÏÑú Ìò∏Ï∂úÎê®
            }

            override fun onError(error: Int) {

                val errorMessage = when (error) {
                    SpeechRecognizer.ERROR_AUDIO -> "Ïò§ÎîîÏò§ ÎÖπÏùå Ïò§Î•ò (ERROR_AUDIO)"
                    SpeechRecognizer.ERROR_CLIENT -> "ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïò§Î•ò (ERROR_CLIENT)"
                    SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Í∂åÌïú Î∂ÄÏ°± (ERROR_INSUFFICIENT_PERMISSIONS)"
                    SpeechRecognizer.ERROR_NETWORK -> "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò (ERROR_NETWORK)"
                    SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "ÎÑ§Ìä∏ÏõåÌÅ¨ ÏãúÍ∞Ñ Ï¥àÍ≥º (ERROR_NETWORK_TIMEOUT)"
                    SpeechRecognizer.ERROR_NO_MATCH -> "ÏùºÏπòÌïòÎäî ÏùåÏÑ± ÏóÜÏùå (ERROR_NO_MATCH)"
                    SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Ïù∏ÏãùÍ∏∞ ÏÇ¨Ïö© Ï§ë (ERROR_RECOGNIZER_BUSY)"
                    SpeechRecognizer.ERROR_SERVER -> "ÏÑúÎ≤Ñ Ïò§Î•ò (ERROR_SERVER)"
                    SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "ÏùåÏÑ± ÏûÖÎ†• ÏãúÍ∞Ñ Ï¥àÍ≥º (ERROR_SPEECH_TIMEOUT)"
                    else -> "Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò: $error"
                }
                sendStatus("STT Ïò§Î•ò: $errorMessage")
                finishSttSession()
            }

            override fun onBeginningOfSpeech() { sendStatus("üó£Ô∏è ÎßêÌïòÍ∏∞ ÏãúÏûë Í∞êÏßÄÎê®") }
            override fun onRmsChanged(rmsdB: Float) { sendRms(rmsdB) }
            override fun onBufferReceived(buffer: ByteArray?) { }
            override fun onEndOfSpeech() { sendStatus("ü§ê ÎßêÌïòÍ∏∞ Ï¢ÖÎ£å Í∞êÏßÄÎê®") }
            override fun onPartialResults(partialResults: Bundle?) { }
            override fun onEvent(eventType: Int, params: Bundle?) { }
        })
    }

    //STT ÏÑ∏ÏÖòÏùÑ Ï¢ÖÎ£åÌïòÍ≥† PorcupineÏùÑ Ïû¨ÏãúÏûëÌïòÎäî Í≥µÌÜµ Ìï®Ïàò
    private fun finishSttSession() {
        sendBroadcast(Intent("com.example.remote.STT_ENDED"))
        Handler(Looper.getMainLooper()).postDelayed({
            try { porcupineManager?.start() } catch (e: Exception) { /* ... */ }
        }, 400)
    }

    private fun extractSummary(result: String): String {
        val clean = result.replace("\\n", "\n")
        val dangerSection = Regex("ÏúÑÌóò[ ]*ÏöîÏÜå[\\s\\S]+?(Ï¶âÏãú|Ïù¥Îü¨Ìïú Ï°∞Ïπò)").find(clean)?.value
        val dangers = mutableListOf<String>()
        dangerSection?.lines()?.forEach { line ->
            val t = line.trim()
            when {
                t.startsWith("ÏúÑÌóò") -> {}
                t.contains(":") -> dangers.add(t.substringBefore(":").trim())
                t.contains(",") -> dangers.addAll(t.split(",").map { it.trim() })
                t.startsWith("-") -> dangers.add(t.removePrefix("-").substringBefore(":").trim())
                t.matches(Regex("^[0-9]+\\..*")) -> {
                    val part = t.substringAfter(".").substringBefore(":").trim()
                    if (part.isNotEmpty()) dangers.add(part)
                }
            }
        }

        val actionSection = Regex("Ï¶âÏãú[\\s\\S]+").find(clean)?.value
        var action: String? = null
        actionSection?.lines()
            ?.firstOrNull { it.trim().startsWith("1.") || it.trim().startsWith("-") }
            ?.let { line ->
                action = line.replace("1.", "")
                    .replace("-", "")
                    .substringBefore(":")
                    .trim()
            }

        val sb = StringBuilder()
        if (dangers.isNotEmpty()) {
            sb.append("ÏúÑÌóòÏöîÏÜå: ").append(dangers.joinToString(", ")).append(". ")
        }
        if (!action.isNullOrBlank()) {
            sb.append("Ï°∞Ïπò: ").append(action).append(" ÌïÑÏöî.")
        }
        return if (sb.isNotEmpty()) sb.toString() else "Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ Î∂àÍ∞Ä"
    }






    // ÏùåÏÑ± ÌÖçÏä§Ìä∏ ‚Üí Ï†úÏñ¥ Î™ÖÎ†π Î≥ÄÌôò
    // ÌïúÍµ≠Ïñ¥ ÌÇ§ÏõåÎìú Îß§Ìïë (Ïïû/Îí§/Ï¢å/Ïö∞/Ï†ïÏßÄ/Î∞úÏÇ¨/Ï∫°Ï≤ò)
    // "nÏ¥à" Ìå®ÌÑ¥ Í∞êÏßÄÌï¥ÏÑú duration Ï∂îÏ∂ú (ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©)
    private fun parseVoiceCommand(text: String): Triple<String, String, Float> {
        // ÌïúÍµ≠Ïñ¥ ÌÇ§ÏõåÎìú ‚Üí Ï†úÏñ¥ Î™ÖÎ†π Îß§Ìïë
        val KOR_DIR = mapOf(
            "Ï†ÑÏßÑ" to "Forward", "Ïïû" to "Forward", "ÏïûÏúºÎ°ú" to "Forward", "ÏßÅÏßÑ" to "Forward",
            "ÌõÑÏßÑ" to "Back", "Îí§" to "Back", "Îí§Î°ú" to "Back",
            "Ï¢å" to "Forward-Left", "Ï¢åÌöåÏ†Ñ" to "Forward-Left", "ÏôºÏ™Ω" to "Forward-Left",
            "Ïö∞" to "Forward-Right", "Ïö∞ÌöåÏ†Ñ" to "Forward-Right", "Ïò§Î•∏Ï™Ω" to "Forward-Right",
            "Ï†ïÏßÄ" to "Stop", "Î©àÏ∂∞" to "Stop", "Î©àÏ∂§" to "Stop", "Ïä§ÌÜ±" to "Stop",
            "Ï†ÑÏüÅ" to "Forward"
        )

        var command: String? = null
        var korCmd: String? = null

        for ((k, v) in KOR_DIR) {
            if (text.contains(k)) {
                command = v
                korCmd = when (v) {
                    "Forward" -> "ÏïûÏúºÎ°ú"
                    "Back" -> "Îí§Î°ú"
                    "Forward-Left" -> "Ï¢åÌöåÏ†Ñ"
                    "Forward-Right" -> "Ïö∞ÌöåÏ†Ñ"
                    "Stop" -> "Ï†ïÏßÄ"
                    else -> k
                }
                break
            }
        }

        if (command == null) {
            if (text.contains("Î¨º") || text.contains("Î∂ÑÏÇ¨")) command = "Launch"
            if (text.contains("Ï∫°Ï≤ò") || text.contains("ÏÇ¨ÏßÑ") || text.contains("Ï∞çÏñ¥")) command = "Capture"
        }

        if (command == null) return Triple("Unknown", text, 0f)
        if (command == "Stop") return Triple("Stop", "Ï†ïÏßÄ", 0f)

        // "5Ï¥à" Í∞ôÏù¥ Ïà´Ïûê+Ï¥à Ìå®ÌÑ¥ Í∞êÏßÄ
        val matcher = Pattern.compile("(\\d+)\\s*Ï¥à").matcher(text)
        val duration = when {
            matcher.find() -> matcher.group(1)?.toFloatOrNull() ?: 5.0f
            command == "Launch" -> 5.0f   // ‚úÖ Î∞úÏÇ¨Îäî Í∏∞Î≥∏ 5Ï¥à
            (command == "Forward-Left" || command == "Forward-Right") -> 3.0f
            else -> 1.0f
        }



        return Triple(command!!, korCmd ?: command!!, duration)
    }


    // STT Í≤∞Í≥ºÎ•º Ïã§Ï†ú ÎèôÏûëÏúºÎ°ú Î∂ÑÍ∏∞
    // Stop ‚Üí Ï¶âÏãú Ï†ïÏßÄ
    // Launch ‚Üí nÏ¥à ÎèôÏïà Î¨º Î∂ÑÏÇ¨
    // Capture ‚Üí ÏÇ¨ÏßÑ Ï¥¨ÏòÅ ÏöîÏ≤≠
    // Î∞©Ìñ•(Forward/Back/Left/Right) ‚Üí runVoiceMacro()Î°ú ÏùºÏ†ï ÏãúÍ∞Ñ Ïù¥Îèô
    // Í∑∏ Ïô∏ ‚Üí ÏùºÎ∞ò ÎåÄÌôîÎ°ú ÏÑúÎ≤Ñ Ï†ÑÏÜ°
    private fun parseAndRouteStt(text: String) {
        voiceMacroJob?.cancel()
        val (command, korCmd, duration) = parseVoiceCommand(text)

        when (command) {
            "Stop" -> {
                RpiWebSocketManager.sendText(JsonFactory.createConMessage("Stop"))
                RpiWebSocketManager.sendText(JsonFactory.createTtsRequestMessage("Ï†ïÏßÄÌï©ÎãàÎã§"))
                finishSttSession()
            }

            "Launch" -> {
                // ÏùåÏÑ±ÏóêÏÑú "nÏ¥à Î∞úÏÇ¨" Í∞êÏßÄ ‚Üí duration ÌôúÏö©
                val durMs = (duration * 1000).toLong().coerceAtLeast(5000L)  // ÏµúÏÜå 0.5Ï¥à
                RpiWebSocketManager.sendText(JsonFactory.createJetMessage("Launch"))

                Handler(Looper.getMainLooper()).postDelayed({
                    RpiWebSocketManager.sendText(JsonFactory.createJetMessage("Stop"))
                    RpiWebSocketManager.sendText(JsonFactory.createTtsRequestMessage("Î∂ÑÏÇ¨Î•º ÏôÑÎ£åÌñàÏäµÎãàÎã§"))
                }, durMs)

                RpiWebSocketManager.sendText(JsonFactory.createTtsRequestMessage("Î¨ºÏùÑ ${duration.toInt()}Ï¥à ÎèôÏïà Î∂ÑÏÇ¨Ìï©ÎãàÎã§"))
                finishSttSession()
            }

            "Capture" -> {
                val intent = Intent(ControllerFragment.ACTION_TRIGGER_CAPTURE)
                sendBroadcast(intent)
                RpiWebSocketManager.sendText(JsonFactory.createTtsRequestMessage("ÏÇ¨ÏßÑÏùÑ Ï¥¨ÏòÅÌï©ÎãàÎã§"))
                finishSttSession()
            }

            // Î∞©Ìñ• Ïù¥Îèô Î™ÖÎ†π Ï≤òÎ¶¨
            "Forward", "Back", "Forward-Left", "Forward-Right" -> {
                RpiWebSocketManager.sendText(
                    JsonFactory.createTtsRequestMessage("$korCmd ${duration.toInt()}Ï¥à Ïù¥ÎèôÌï©ÎãàÎã§")
                )
                runVoiceMacro(command, duration) // ‚Üí Ïó¨Í∏∞ÏÑú ÎÅùÎÇòÎ©¥ Stop + ÏôÑÎ£å TTS + finishSttSession()
            }

            else -> {
                // ÏùºÎ∞ò ÎåÄÌôî
                val sttJson = JsonFactory.createSttMessage(text)
                sendWhenReady(sttJson)
                sendStatus("‚¨ÜÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ° (ÎåÄÌôî): $text")
                finishSttSession()
            }
        }
    }


    //ÏãúÍ∞Ñ Ï†úÏñ¥ Îß§ÌÅ¨Î°ú Ïã§Ìñâ
    private fun runVoiceMacro(command: String, duration: Float) {
        voiceMacroJob = serviceScope.launch {
            setControlLock(true)
            val startTime = System.currentTimeMillis()
            try {
                while (isActive && (System.currentTimeMillis() - startTime) < (duration * 1000)) {
                    RpiWebSocketManager.sendText(JsonFactory.createConMessage(command))
                    delay(200)
                }
            } finally {
                RpiWebSocketManager.sendText(JsonFactory.createConMessage("Stop"))
                setControlLock(false)
                RpiWebSocketManager.sendText(JsonFactory.createTtsRequestMessage("Î™ÖÎ†πÏùÑ ÏôÑÎ£åÌñàÏäµÎãàÎã§"))
                finishSttSession() //Ïù¥ÎèôÏù¥ ÎÅùÎÇú Îí§ÏóêÎßå Ìò∏Ï∂ú
            }
        }
    }

    private fun sendControlCommandToFragment(commandJson: String) {
        val intent = Intent(ACTION_SEND_CONTROL_COMMAND).apply {
            putExtra(EXTRA_CONTROL_COMMAND_JSON, commandJson)
        }
        sendBroadcast(intent)
    }

    //Ï°∞Ïù¥Ïä§Ìã± Ï†úÏñ¥ Ïû†Í∏à/Ìï¥Ï†ú ÏÉÅÌÉúÎ•º BroadcastÎ°ú ControllerFragmentÏóê Ï†ÑÎã¨
    private fun setControlLock(isLocked: Boolean) {
        val intent = Intent(ACTION_SET_CONTROL_LOCK).apply {
            putExtra(EXTRA_IS_LOCKED, isLocked)
        }
        sendBroadcast(intent)
    }


    private fun startSTT() {
        if (!isController()) {
            sendStatus("RC Î™®ÎìúÏóêÏÑúÎäî STTÍ∞Ä ÎπÑÌôúÏÑ±ÏûÖÎãàÎã§.")
            return
        }
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)
            != PackageManager.PERMISSION_GRANTED) {
            sendStatus("ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.")
            return
        }
        speechRecognizer?.startListening(recognizerIntent)
        sendStatus("üéô ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûë")
    }

    private fun stopSTT() {
        try {
            speechRecognizer?.stopListening()
        } catch (_: Exception) {}
        sendStatus("‚õî ÏùåÏÑ± Ïù∏Ïãù Ï§ëÏßÄ")
        sendBroadcast(Intent("com.example.remote.STT_ENDED"))

        if (isController()) {
            Handler(Looper.getMainLooper()).postDelayed({
                try {
                    porcupineManager?.start()
                    sendStatus("üü¢ Ìò∏Ï∂úÏñ¥ ÎåÄÍ∏∞ Ïû¨Í∞ú")
                } catch (e: Exception) {
                    sendStatus("‚ùå Ìò∏Ï∂úÏñ¥ Ïû¨ÏãúÏûë Ïã§Ìå®: ${e.message}")
                }
            }, 400)
        }
    }

    private fun sendStatus(msg: String) {
        sendBroadcast(Intent(ACTION_UPDATE_STATUS).apply {
            putExtra(EXTRA_STATUS_MESSAGE, msg)
        })
    }

    private fun sendRms(rms: Float) {
        sendBroadcast(Intent(ACTION_UPDATE_RMS).apply {
            putExtra(EXTRA_RMS_VALUE, rms)
        })
    }

    private fun logConversation(type: String, content: String) {
        // BroadcastÎßå Ïú†ÏßÄ
        sendBroadcast(Intent(ACTION_LOG_CONVERSATION).apply {
            putExtra(EXTRA_LOG_TYPE, type)
            putExtra(EXTRA_LOG_CONTENT, content)
        })
    }
    private fun getAssetFilePath(file: String): String {
        val outFile = File(filesDir, file)
        if (!outFile.exists()) {
            assets.open(file).use { input -> FileOutputStream(outFile).use { output -> input.copyTo(output) } }
        }
        return outFile.absolutePath
    }

    private fun sendWhenReady(json: String, retries: Int = 6) {
        serviceScope.launch {
            repeat(retries) {
                if (wsManager.isConnected()) {
                    wsManager.sendText(json)
                    return@launch
                }
                delay(500)
            }
            sendStatus("‚ö†Ô∏è ÏÑúÎ≤ÑÏóê Ï†ÑÏÜ° Ïã§Ìå®(Ïó∞Í≤∞ ÏßÄÏó∞)")
        }
    }

    private fun log(msg: String) = Log.d("PorcupineService", msg)
}
